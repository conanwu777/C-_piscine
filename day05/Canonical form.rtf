{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;\red1\green37\blue160;\red247\green249\blue251;\red0\green0\blue0;
\red26\green26\blue26;}
{\*\expandedcolortbl;;\cssrgb\c0\c23137\c69020;\cssrgb\c97647\c98039\c98824;\cssrgb\c0\c0\c0;
\cssrgb\c13333\c13333\c13333;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl240\sa192\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\ul \ulc2 \outl0\strokewidth0 \strokec2 This brings us to what is called the "canonical class form." In MFC, all our classes follow a standard template, unless we have a reason to limit the functionality of a class. If you follow this canonical class form, then classes you write will behave much like intrinsic types (int, char, and so on), since they can be created, assigned, and copied just like variables of intrinsic types.\cb1 \ulnone \
\cb3 \ul But as stated, MFC implements a private assignment operator and a private copy constructor in the CObject class; see\'a0{\field{\*\fldinst{HYPERLINK "http://www.drdobbs.com/cpp/designing-c-classes/184408873#0261_0006"}}{\fldrslt Example 3}}\cf4 \ulnone \strokec4 . This means that derived classes can safely not supply implementations of these functions, especially since it often doesn't make sense to permit two objects to be equal (for example, a class that maintains a reference to some system-allocated resource, such as a file).\
\pard\pardeftab720\sl240\sa192\partightenfactor0
{\field{\*\fldinst{HYPERLINK "http://www.drdobbs.com/cpp/designing-c-classes/184408873"}}{\fldrslt 
\fs26 \cf4 http://www.drdobbs.com/cpp/designing-c-classes/184408873}}
\fs26 \
\
\pard\pardeftab720\sl340\partightenfactor0

\f1\fs30 \cf5 \cb1 \strokec5 The orthodox canonical class form is a recipe, if you will, for proper class design. At the very least, the OCCF specifies four required functions that you implement when declaring user-defined data types to ensure they behave correctly in the four basic object usage contexts. By implementing the OCCF in user-defined types you increase your situational awareness regarding object usage. In this capacity the OCCF is much more than a recipe for correct object behavior \'97 it is a fundamental stepping stone toward an understanding of more advanced C++ idiomatic constructs. An intuitive understanding of the OCCF will empower you to write C++ classes that are better suited to play well in complex, object-oriented applications.
\f0\fs26 \cf4 \cb3 \strokec4 \
\
\pard\pardeftab720\sl240\sa192\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://flylib.com/books/en/2.937.1.244/1/"}}{\fldrslt \cf4 https://flylib.com/books/en/2.937.1.244/1/}}}